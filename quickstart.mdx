---
title: "Quickstart"
description: "Start building awesome documentation in minutes"
---
export const metadata = {
  title: 'Quickstart',
  description:
    'Transfer a file peer-to-peer between endpoints',
};


Let's dive into iroh by building a simple peer-to-peer file transfer tool in rust! 

## Get set up

We'll assume you've set up [rust](https://www.rust-lang.org/) and
[cargo](https://doc.rust-lang.org/cargo/) on your machine.

Initialize a new project by running:

```bash
cargo init ping-pong
cd ping-pong
```

Now, add the dependencies we'll need for this example:

```bash
cargo add iroh iroh-ping tokio anyhow
```

From here on we'll be working inside the `src/main.rs` file.


## Create an `iroh::Endpoint`

To start interacting with other iroh endpoints, we need to build an `iroh::Endpoint`.
This is what manages the possibly changing network underneath, maintains a
connection to the closest relay, and finds ways to address devices by
`EndpointId`.

```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Create an endpoint, it allows creating and accepting
    // connections in the iroh p2p world
    let endpoint = Endpoint::bind().await?;

    // ...

    Ok(())
}
```

There we go, this is all we need to [open
connections](https://docs.rs/iroh/latest/iroh/endpoint/struct.Endpoint.html#method.connect)
or [accept
them](https://docs.rs/iroh/latest/iroh/endpoint/struct.Endpoint.html#method.accept).

<Note>
Here, we're specifically configuring the `Endpoint`'s builder to include "number 0 discovery".
This makes it connect to DNS servers that [number 0](https://n0.computer) runs to find which relay to talk to for specific `EndpointId`s.
It's a great default!

The iroh toolkit is built to be modular and flexible, so if you want to use a different discovery mechanism, you can!

If all of this is too much magic for your taste, it's possible for the endpoint to work entirely without any discovery services.
In that case, you'll need to make sure you're not only dialing by `EndpointId`, but also help the `Endpoint` out with giving it the whole [`EndpointAddr`](https://docs.rs/iroh/latest/iroh/struct.EndpointAddr.html) when connecting.
</Note>


## Protocols

Now that we have an `Endpoint`, we can start using protocols over it. A protocol
is a specific way of exchanging messages over a connection.

Similar to how HTTP is a protocol for exchanging web pages, iroh protocols define
ways to exchange data over iroh connections.

Each endpoint can support multiple protocols, identified by a string called
an ALPN string. This just tells the program which handler to use for
processing data as it arrives.

When building applications with iroh, you can either build your own custom
protocol handlers, or use existing ones.    

<Note>
Learn more about writing your own protocol on the [protocol documentation page](/protocols/writing-a-protocol).
</Note>

### Ping: Receive

iroh-ping is a diagnostic protocol bundled with iroh that lets two endpoints
exchange lightweight ping/pong messages to prove connectivity, measure
round-trip latency, or whatever else you want to build on top of it, without building a custom handler.

```rust
use anyhow::Result;
use iroh::{protocol::Router, Endpoint, Watcher};
use iroh_ping::Ping;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Create an endpoint, it allows creating and accepting
    // connections in the iroh p2p world
    let recv_ep = Endpoint::builder().bind().await?;

    // Then we initialize a struct that can accept ping requests over iroh connections
    let ping = Ping::new();

    // receiving ping requests
    let recv_router = Router::builder(recv_ep)
        .accept(iroh_ping::ALPN, ping)
        .spawn();

    // ...

    Ok(())
}
```

With these two lines, we've initialized iroh-blobs and gave it access to our `Endpoint`.

At this point what we want to do depends on whether we want to accept incoming iroh connections from the network or create outbound iroh connections to other endpoints.
Which one we want to do depends on if the executable was called with `send` as
an argument or `receive`, so let's parse these two options out from the CLI
arguments and match on them:

```rust
use anyhow::Result;
use iroh::{protocol::Router, Endpoint, Watcher};
use iroh_ping::Ping;

#[tokio::main]
async fn main() -> Result<()> {
    // Create an endpoint, it allows creating and accepting
    // connections in the iroh p2p world
    let recv_ep = Endpoint::builder().bind().await?;

    // Then we initialize a struct that can accept ping requests over iroh connections
    let ping = Ping::new();

    // receiving ping requests
    let recv_router = Router::builder(recv_ep)
        .accept(iroh_ping::ALPN, ping)
        .spawn();

    // get the address of this endpoint to share with the sender
    let addr = recv_router.endpoint().addr();

    // create a send side & send a ping
    let send_ep = Endpoint::builder().bind().await?;
    let send_pinger = Ping::new();
    let rtt = send_pinger.ping(&send_ep, addr).await?;

    println!("ping took: {:?} to complete", rtt);
    Ok(())
}
```


### Getting round trip time

Now that we've created both the sending and receiving sides of our ping program, we can run it!

```
cargo run
```

```bash
I   Compiling ping-quickstart v0.1.0 (/Users/raemckelvey/dev/ping-quickstart)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running `target/debug/ping-quickstart`
accepted connection from 32c5772d26bff78923ef6e85f665f23b96ee06655832649910a560af59c84e22
ping took: 1.189375ms to complete
```


## That's it!

You've now successfully built a small tool for sending messages over a peer to peer network! ðŸŽ‰

The full example with the very latest version of iroh and iroh-ping can be [viewed on github](https://github.com/n0-computer/iroh-blobs/blob/main/examples/transfer.rs).

If you're hungry for more, check out
- the [iroh rust documentation](https://docs.rs/iroh),
- Blob storage with [iroh-blobs](/protocols/blobs),
- [other examples](/examples)
